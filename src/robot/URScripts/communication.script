################################################################
## communication.script
## Implements the communication protocol with a client (master) machine.
################################################################
def com():    
    import timer.script
    import sensor.script
    import arm.script

    # parse and execute a command
    def com_execute_cmd(cmd):
        cmd_time = ur_time
        #textmsg("parsing command at ", cmd_time)
        # we expect a vector of 23 values, the first one being the count
        # the other values depend on command:
        #CMD_STOP/CMD_READ: last response time, cmd code
        #CMD_MOVE/CMD_MOVEJ: last response time, cmd code, target pose (vec6), max speed, max acc, target speed (vec6), tcp force limits (vec6).
        #CMD_CONFIG: last response time, cmd code, payload (kg), tool center of gravity (vec3), tool tip (vec6), reset F/T sensor
        #CMD_CALIB: last response time, cmd code, payload (kg), tool center of gravity (vec3), tool tip (vec6), reset F/T sensor
        cmd_time_prev = cmd[1] #last response time, cmd code
        cmd_id = cmd[2]
        
        if cmd_id == 0: #CMD_STOP
            ur_stop(cmd_time)
            return cmd_time
        end
        if cmd_id == 1: #CMD_READ
            return 0
        end

        if cmd_id == 10: #CMD_CONFIG
            set_tcp(p[cmd[7], cmd[8], cmd[9], cmd[10], cmd[11], cmd[12]]) 
            set_payload(cmd[3], [cmd[4], cmd[5], cmd[6]])
            #ft_set_zero()
            return 0
        end

        if cmd_id == 11: #CMD_CALIB
            ur_calib(cmd_time)
            return 0
        end

        # the rest of the commands are move commands
        is_tool_pose = (cmd_id == 3) or (cmd_id == 4) #CMD_MOVEP or CMD_MOVE
        movej = (cmd_id == 2) or (cmd_id == 3) #CMD_MOVEJ or CMD_MOVEP
        target_pose = [cmd[3], cmd[4], cmd[5], cmd[6], cmd[7], cmd[8]]
        acc = cmd[9]
        max_speed = cmd[10]
        max_force = [cmd[11], cmd[12], cmd[13], cmd[14], cmd[15], cmd[16]]
        target_speed = [cmd[17], cmd[18], cmd[19], cmd[20], cmd[21], cmd[22]]
        ur_drive(cmd_time, target_pose, target_speed, max_speed, acc, is_tool_pose, movej, max_force)
        return cmd_time
    end

    # sends the response packet containing arm status
    def com_send_response(cmd_time):
        # ur_get_state needs to be called first, as it might take more than one cycle to complete
        cmd_state = ur_get_state(cmd_time) # returns [cmd time, status, corrected force vec3]
        q = get_actual_joint_positions()
        qd = get_actual_joint_speeds()
        tp = get_actual_tcp_pose()
        tv = get_actual_tcp_speed()

        q_t = get_target_joint_positions()
        qd_t = get_target_joint_speeds()
        tp_t = get_target_tcp_pose()
        tv_t = get_target_tcp_speed()
        
        f = get_tcp_force()
        m = get_joint_torques() 
        a = ur_get_tcp_acceleration()
        ft = ur_get_tcp_sensor_force() #FT sensor reading
        
        socket_send_string([ur_time, 
                            q[0], q[1], q[2], q[3], q[4], q[5], 
                            qd[0], qd[1], qd[2], qd[3], qd[4], qd[5], 
                            tp[0], tp[1], tp[2], tp[3], tp[4], tp[5], 
                            tv[0], tv[1], tv[2], tv[3], tv[4], tv[5], 
                            
                            q_t[0], q_t[1], q_t[2], q_t[3], q_t[4], q_t[5], 
                            qd_t[0], qd_t[1], qd_t[2], qd_t[3], qd_t[4], qd_t[5], 
                            tp_t[0], tp_t[1], tp_t[2], tp_t[3], tp_t[4], tp_t[5], 
                            tv_t[0], tv_t[1], tv_t[2], tv_t[3], tv_t[4], tv_t[5],
                            
                            m[0], m[1], m[2], m[3], m[4], m[5], 
                            f[0], f[1], f[2], f[3], f[4], f[5], 
                            ft[0], ft[1], ft[2], ft[3], ft[4], ft[5], 
                            a[0], a[1], a[2], 
                            cmd_state[2], cmd_state[3],cmd_state[4], cmd_state[5], cmd_state[6],cmd_state[7],
							cmd_state[0], # cmd time
                            cmd_state[1]	 # status (-1 = force limited, 0 = done, 1 = moving)
                            ], 
                            "ctrl")
    end

    popup("running")

    # connect with the client
    com_connected = False
    while not com_connected:
        com_connected = socket_open("192.168.1.10",50003,"ctrl")
    end
   
    # forever, read commands and write responses
    CMD_ENTRIES_COUNT = 22
    while True:    
        cmd = socket_read_ascii_float(CMD_ENTRIES_COUNT, "ctrl") 
        #acquire the critical section as early as possible, to preempt the drive thread. This ensures everything takes place in one timestep.
        enter_critical
        if CMD_ENTRIES_COUNT == cmd[0]:
            #textmsg("received data ", ur_time)
            cmd_time = com_execute_cmd(cmd)
        end
        exit_critical
        if cmd[0] == 0:
            continue
        end
        if CMD_ENTRIES_COUNT != cmd[0]:
            textmsg("invalid request ", cmd)
            break
        end
        com_send_response(cmd_time)
        #textmsg("response sent ", cmd_time)
    end
    popup("script exited")
end # communication.script
