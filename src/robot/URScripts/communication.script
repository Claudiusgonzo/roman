import timer
import sensor
import arm
import drive

################################################################
## communication.script
## Implements the communication protocol with a client (master) machine.
################################################################

# constants
CMD_ENTRIES_COUNT = 22 # this is how many floats we expect with each command

# parse and execute a command
def com_execute_cmd(cmd):
    cmd_time = ur_time
    #textmsg("parsing command at ", cmd_time)
    # We expect a vector of 23 values (UR requires that the total must stay under 30)
    # The first value is the count,
    # the other 22 values depend on command:
    #CMD_READ: last response time, cmd code
    #CMD_MOVE/CMD_MOVEJ: last response time, cmd code, target pose (vec6), max speed, max acc, target speed (vec6), tcp force limits (vec6).
    #CMD_CONFIG: last response time, cmd code, payload (kg), tool center of gravity (vec3), tool tip (vec6), reset F/T sensor
    cmd_time_prev = cmd[1] #last response time, cmd code
    cmd_id = cmd[2]
    
    if cmd_id == 0: #CMD_CONFIG
        set_tcp(p[cmd[7], cmd[8], cmd[9], cmd[10], cmd[11], cmd[12]]) 
        set_payload(cmd[3], [cmd[4], cmd[5], cmd[6]])
        #ft_set_zero()
        return 0
    end

    if cmd_id == 1: #CMD_READ
        return 0
    end

    # the rest of the commands are move commands
    if cmd_id == 2: #CMD_MOVEJ
        cmd_type = UR_CMD_TYPE_POSITION
        is_tool_pose = False
    elif cmd_id == 3: #CMD_MOVEP
        cmd_type = UR_CMD_TYPE_POSITION
        is_tool_pose = True
    elif cmd_id == 4: #CMD_MOVE
        cmd_type = UR_CMD_TYPE_POSITION_WITH_LINEAR_MOTION
        is_tool_pose = True
    end
    target_pose = [cmd[3], cmd[4], cmd[5], cmd[6], cmd[7], cmd[8]]
    max_acc = cmd[9]
    max_speed = cmd[10]
    expected_force = [cmd[11], cmd[12], cmd[13], cmd[14], cmd[15], cmd[16]]
    max_force = [cmd[17], cmd[18], cmd[19], cmd[20], cmd[21], cmd[22]]
    ur_drive(cmd_time, cmd_type, target_pose, max_speed, max_acc, expected_force, max_force, is_tool_pose)
    return cmd_time
end

# sends the response packet containing arm status
def com_send_response(cmd_time):
    # ur_get_state needs to be called first, as it might take more than one cycle to complete
    s = ur_get_state(cmd_time) # returns [cmd time, moving & contact, contact force vec6]
    q = get_actual_joint_positions()
    qd = get_actual_joint_speeds()
    tp = get_actual_tcp_pose()
    tv = get_actual_tcp_speed()

    q_t = get_target_joint_positions()
    qd_t = get_target_joint_speeds()
    tp_t = get_target_tcp_pose()
    tv_t = get_target_tcp_speed()
    
    f = get_tcp_force()
    m = get_joint_torques() 
    a = ur_get_tcp_acceleration()
    ft = ur_get_tcp_sensor_force() #FT sensor reading
    
    socket_send_string([ur_time, 
                        q[0], q[1], q[2], q[3], q[4], q[5], 
                        qd[0], qd[1], qd[2], qd[3], qd[4], qd[5], 
                        tp[0], tp[1], tp[2], tp[3], tp[4], tp[5], 
                        tv[0], tv[1], tv[2], tv[3], tv[4], tv[5], 
                        
                        q_t[0], q_t[1], q_t[2], q_t[3], q_t[4], q_t[5], 
                        qd_t[0], qd_t[1], qd_t[2], qd_t[3], qd_t[4], qd_t[5], 
                        tp_t[0], tp_t[1], tp_t[2], tp_t[3], tp_t[4], tp_t[5], 
                        tv_t[0], tv_t[1], tv_t[2], tv_t[3], tv_t[4], tv_t[5],
                        
                        m[0], m[1], m[2], m[3], m[4], m[5], 
                        f[0], f[1], f[2], f[3], f[4], f[5], 
                        ft[0], ft[1], ft[2], ft[3], ft[4], ft[5], 
                        a[0], a[1], a[2], 
                        s[2], s[3], s[4], s[5], s[6],s[7], # external force 
                        s[0], # cmd time
                        s[1]  # state flags: bit 0: moving, bit 1: contact 
                        ], 
                        "ctrl")
end

