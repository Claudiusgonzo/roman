import math
import sensor
import timer

################################################################
## arm.script
################################################################

# globals
ur_acc_bias = [0,0,0]

# Computes the speed required to comply with the external force
def ur_force_control(external_force):
    return [0,0,0,0,0,0]
end

# generates a trapezoidal speed profile for one joint 
def ur_speed_from_joint_position(current_pos, current_speed, target_pos, max_speed, acc):
    distance = target_pos - current_pos
    lim = 0
    if (distance * current_speed) > 0: # is the joint rotating in the right direction?
        lim = 0.5*current_speed*current_speed/acc
    end
    if math_abs(distance)>lim + 0.001:
        if distance<0: 
            return -max_speed
        end
        return max_speed
    end
    return 0.0
end

# generates a trapezoidal speed profile for each joint, independent of each other 
def ur_position_control(target_position, max_speed, max_acc):
    joint_positions = get_actual_joint_positions()
    joint_speeds = get_actual_joint_speeds()
    return [
        ur_speed_from_joint_position(joint_positions[0], joint_speeds[0], target_position[0], max_speed, max_acc),
        ur_speed_from_joint_position(joint_positions[1], joint_speeds[1], target_position[1], max_speed, max_acc),
        ur_speed_from_joint_position(joint_positions[2], joint_speeds[2], target_position[2], max_speed, max_acc),
        ur_speed_from_joint_position(joint_positions[3], joint_speeds[3], target_position[3], max_speed, max_acc),
        ur_speed_from_joint_position(joint_positions[4], joint_speeds[4], target_position[4], max_speed, max_acc),
        ur_speed_from_joint_position(joint_positions[5], joint_speeds[5], target_position[5], max_speed, max_acc)
    ]
end

# rotates a force vector from tool coordinate system to base coordinate system
def ur_rotate_from_tool_to_base(vec3):
    vec3_T = p[ vec3[0], vec3[1], vec3[2], 0, 0, 0 ]
    tcp = get_actual_tcp_pose()
    rotation = p[ 0, 0, 0, tcp[3], tcp[4], tcp[5] ]
    vec3_B = pose_trans(rotation, vec3_T )
    return [vec3_B[0], vec3_B[1], vec3_B[2]]
end

# rotates a force vector from base coordinate system to tool coordinate system
def ur_rotate_from_base_to_tool(vec3):
    vec3_B = p[ vec3[0], vec3[1], vec3[2], 0, 0, 0 ]
    tcp = get_actual_tcp_pose()
    rotation = p[ 0, 0, 0, -tcp[3], -tcp[4], -tcp[5] ]
    vec3_T = pose_trans(rotation, vec3_B )
    return [vec3_T[0], vec3_T[1], vec3_T[2]]
end

# returns the accelerometer reading in tool coordinates, corrected for bias and flipped axes 
def ur_get_tool_accelerometer_reading():
    a = get_tool_accelerometer_reading() 
    return [a[1]+ ur_acc_bias[0], a[0]+ur_acc_bias[1], a[2]+ur_acc_bias[2]] # accelerometer x and y axes are reversed - UR bug
end

# returns the accelerometer reading in robot base coordinates, excluding gravity
def ur_get_tcp_acceleration():
    a = ur_get_tool_accelerometer_reading()
    a_base = ur_rotate_from_tool_to_base(a) 
    return [a_base[0], a_base[1], a_base[2]+9.8]
end

# returns the FT sensor reading in robot base coordinates, excluding the hand weight (assumes the FT sensor was pre-calibrated to account for the weight)
def ur_get_tcp_sensor_force(critical_section_already_acquired = False):
    ft = ft_get(critical_section_already_acquired)
    ft_force = ur_rotate_from_tool_to_base([ft[0], ft[1], ft[2]])
    ft_torque = ur_rotate_from_tool_to_base([ft[3], ft[4], ft[5]])
    return [ft_force[0], ft_force[1], ft_force[2], ft_torque[0], ft_torque[1], ft_torque[2]]
end

# is the sample greater than the threshold?
def ur_force_limit_exceeded(sample, pain_threshold):
    sample_abs = math_abs_vec6(sample)
    exceeded = not math_gt_vec6(pain_threshold, sample_abs)
    return exceeded
end

# determine accelerometer bias (assumes arm is stopped)
def ur_calibrate_accelerometer():
    i = 0
    actual = [0,0,0]
    while i < 125:
        acc = ur_get_tool_accelerometer_reading() 
        actual = [actual[0] + acc[0], actual[1] + acc[1], actual[2] + acc[2]]
        i = i+1
        sync()
    end
    actual = [actual[0]/i, actual[1]/i, actual[2]/i]
    expected = ur_rotate_from_base_to_tool([0,0,-9.8])
    ur_acc_bias = [expected[0] - actual[0], expected[1] - actual[1], expected[2] - actual[2]]
end

# verifies that the control loop runs fast enough. Depends on the timer module for ur_time.
def ur_check_loop_delay(loop_time):
    delay = ur_time - loop_time
    if delay >= 0.016:
        textmsg("drive loop delayed: ", delay)
    end
    return ur_time
end


