################################################################
## gripper.script
## Robotiq 3-finger gripper control.
## The script is as provided by Robotiq, with the global variable names changed to include the rq_ prefix, to avoid conflict.
## Note that the gripper functions typically loop waiting for completion, so it's best to invoke them on a separate thread.
################################################################
def gripper():
    # output registers are used to send commands
    modbus_add_signal("192.168.1.11", 255, 0, 3, "gripper_O0")
    modbus_set_signal_update_frequency("gripper_O0", 10)
    modbus_add_signal("192.168.1.11", 255, 1, 3, "gripper_O1")
    modbus_set_signal_update_frequency("gripper_O1", 10)
    modbus_add_signal("192.168.1.11", 255, 2, 3, "gripper_O2")
    modbus_set_signal_update_frequency("gripper_O2", 10)
    modbus_add_signal("192.168.1.11", 255, 3, 3, "gripper_O3")
    modbus_set_signal_update_frequency("gripper_O3", 10)
    modbus_add_signal("192.168.1.11", 255, 4, 3, "gripper_O4")
    modbus_set_signal_update_frequency("gripper_O4", 10)
    modbus_add_signal("192.168.1.11", 255, 5, 3, "gripper_O5")
    modbus_set_signal_update_frequency("gripper_O5", 10)
    modbus_add_signal("192.168.1.11", 255, 6, 3, "gripper_O6")
    modbus_set_signal_update_frequency("gripper_O6", 10)
    modbus_add_signal("192.168.1.11", 255, 7, 3, "gripper_O7")
    modbus_set_signal_update_frequency("gripper_O7", 10)
    # input registers are used to receive status
    modbus_add_signal("192.168.1.11", 255, 0, 2, "gripper_I0")
    modbus_set_signal_update_frequency("gripper_I0", 10)
    modbus_add_signal("192.168.1.11", 255, 1, 2, "gripper_I1")
    modbus_set_signal_update_frequency("gripper_I1", 10)
    modbus_add_signal("192.168.1.11", 255, 2, 2, "gripper_I2")
    modbus_set_signal_update_frequency("gripper_I2", 10)
    modbus_add_signal("192.168.1.11", 255, 3, 2, "gripper_I3")
    modbus_set_signal_update_frequency("gripper_I3", 10)
    modbus_add_signal("192.168.1.11", 255, 4, 2, "gripper_I4")
    modbus_set_signal_update_frequency("gripper_I4", 10)
    modbus_add_signal("192.168.1.11", 255, 5, 2, "gripper_I5")
    modbus_set_signal_update_frequency("gripper_I5", 10)
    modbus_add_signal("192.168.1.11", 255, 6, 2, "gripper_I6")
    modbus_set_signal_update_frequency("gripper_I6", 10)
    modbus_add_signal("192.168.1.11", 255, 7, 2, "gripper_I7")
    modbus_set_signal_update_frequency("gripper_I7", 10)
    #set_analog_inputrange(0, 0)
    #set_analog_inputrange(1, 0)
    #set_analog_inputrange(2, 0)
    #set_analog_inputrange(3, 0)
    #set_analog_outputdomain(0, 0)
    #set_analog_outputdomain(1, 0)
    #set_runstate_outputs([])
    modbus_set_runstate_dependent_choice("gripper_O0",1)
    modbus_set_runstate_dependent_choice("gripper_O1",1)
    modbus_set_runstate_dependent_choice("gripper_O2",1)
    modbus_set_runstate_dependent_choice("gripper_O3",1)
    modbus_set_runstate_dependent_choice("gripper_O4",1)
    modbus_set_runstate_dependent_choice("gripper_O5",1)
    modbus_set_runstate_dependent_choice("gripper_O6",1)
    modbus_set_runstate_dependent_choice("gripper_O7",1)



    # aliases for the gripper output names
    # those values also represent offsets 
    # in control registers
    rq_rACT = 1
    rq_rMOD = 2
    rq_rGTO = 8
    rq_rATR = 16
    rq_rPOS = 3
    rq_rFOR = 5
    rq_rSPE = 11

    # aliases for the gripper input names
    # those values also represent offsets 
    # in control registers
    rq_gPRE = 1
    rq_gACT = 8
    rq_gMOD = 9
    rq_gMOD1 = 9
    rq_gMOD2 = 10
    rq_gFLT = 19
    rq_gFLT1 = 8
    rq_gFLT2 = 9
    rq_gFLT3 = 10
    rq_gFLT4 = 11
    rq_gGTO = 11
    rq_gIMC = 12
    rq_gIMC1 = 12
    rq_gIMC2 = 13
    rq_gSTA = 14
    rq_gSTA1 = 14
    rq_gSTA2 = 15

    # send the activation request to the gripper.
    def rq_activate():
	    rq_set_var(rq_rACT,1)

	    ACT = rq_get_var(rq_gACT)
	    while (ACT != 1):
		    ACT = rq_get_var(rq_gACT)
	    end
    end

    # send the activation request to the gripper and
    # wait for its completion.
    def rq_activate_and_wait():
	    rq_activate()

	    while(not rq_is_gripper_activated()):
		    # wait for activation completed
	    end
    end

    # interrupts the gripper motion.
    def rq_stop():
	    rq_set_var(rq_rGTO,0)

	    GTO = rq_get_var(rq_gGTO)
	    while (GTO != 0):
		    GTO = rq_get_var(rq_gGTO)
	    end
    end

    # resets the activation and auto-release bits.
    def rq_reset():
	    rq_set_var(rq_rATR,0)
	    rq_set_var(rq_rACT,0)

	    ACT = rq_get_var(rq_gACT)
	    while (ACT != 0):
		    ACT = rq_get_var(rq_gACT)
	    end
    end

    # send the auto-release request and wait 
    # for its completion
    def rq_auto_release_and_wait():
	    rq_set_var(rq_rACT,1)
	    rq_set_var(rq_rATR,1)

	    ACT = rq_get_var(rq_gACT)
	    while (ACT != 1):
		    ACT = rq_get_var(rq_gACT)
	    end

	    FLT = rq_get_var(rq_gFLT)
	    while(FLT != 15):
		    FLT = rq_get_var(rq_gFLT)
	    end
    end

    # set the force setpoint
    def rq_set_force(force):
	    rq_set_var(rq_rFOR,force)
    end

    # set the speed setpoint
    def rq_set_speed(speed):
	    rq_set_var(rq_rSPE,speed)
    end

    # send the open request to the gripper
    def rq_open():
	    rq_move(0)
    end

    # send the close request to the gripper
    def rq_close():
	    rq_move(255)
    end

    # send the open request to the gripper and wait
    # for its completion
    def rq_open_and_wait():
	    rq_move_and_wait(0)
    end

    # send the close request to the gripper and wait
    # for its completion
    def rq_close_and_wait():
	    rq_move_and_wait(255)
    end

    # send the move request to the position in argument
    def rq_move(pos):
	    rq_set_var(rq_rGTO,0)

	    GTO = rq_get_var(rq_gGTO)
	    while (GTO != 0):
		    GTO = rq_get_var(rq_gGTO)
	    end

	    rq_set_var(rq_rPOS,pos)
	
	    PRE = rq_get_var(rq_gPRE)
	    while (PRE != pos):
		    PRE = rq_get_var(rq_gPRE)
	    end

	    rq_set_var(rq_rGTO,1)

	    while (GTO != 1):
		    GTO = rq_get_var(rq_gGTO)
	    end
		
    end

    # send the move request to the position in argument
    # and wait for its completion
    def rq_move_and_wait(pos):
	    rq_move(pos)

	    while (not rq_is_motion_complete()):
		    # wait for motion completed
		    sleep(0.01)
		    sync()
	    end
    end

    # send the request to change mode in argument
    def rq_set_mode(value):
	    rq_set_var(rq_rMOD, value)

	    MOD = rq_get_var(rq_gMOD)
	    while (MOD != value):
		    MOD = rq_get_var(rq_gMOD)
	    end
    end

    # send the request to change to the basic mode
    def rq_set_basic_mode():
	    rq_set_mode(0)
    end

    # send the request to change to the pinch mode
    def rq_set_pinch_mode():
	    rq_set_mode(1)
    end

    # send the request to change to the wide mode
    def rq_set_wide_mode():
	    rq_set_mode(2)
    end

    # send the request to change to the scissor mode
    def rq_set_scissor_mode():
	    rq_set_mode(3)
    end

    def rq_wait_for_motion():
        while (not rq_is_motion_complete()):
		    # wait for motion completed
		    sleep(0.01)
		    sync()
	    end
    end

    # returns True if the gripper has completed its motion
    # returns False otherwise
    def rq_is_motion_complete():
	    STA = rq_get_var(rq_gSTA)

	    if (STA == 0):
		    return False
	    end

	    return True

    end

    # Returns True if the gripper is activated
    def rq_is_gripper_activated():
	    IMC = rq_get_var(rq_gIMC)
    
	    if (IMC == 3):
		    return True
	    end

	    return False
    end

    # returns True if an object has been detected
    def rq_is_object_detected():
	    STA = rq_get_var(rq_gSTA)

	    if(STA == 1):
		    return True
	    elif(STA == 2):
		    return True
	    else:
		    return False
	    end
    end

    # prints in the log window the fault status
    def rq_print_fault_code():
	    fault_status = rq_get_var(rq_gFLT)

	    if(fault_status == 0):
		    textmsg("Gripper Fault : ", "No Fault (0x00)")
	    elif (fault_status == 5):
		    textmsg("Gripper Fault : ", "Priority Fault: Action delayed, activation (reactivation) must be completed prior to renewed action (0x05)")
	    elif (fault_status == 6):
		    textmsg("Gripper Fault : ", "Priority Fault: Action delayed, mode change must be completed prior to continuing action (0x06)")
	    elif (fault_status == 7):
		    textmsg("Gripper Fault : ", "Priority Fault: The activation bit must be set prior to action (0x07)")
	    elif (fault_status == 9):
		    textmsg("Gripper Fault : ", "Minor Fault: The communication chip is not ready (may be booting) (0x09)")
	    elif (fault_status == 10):
		    textmsg("Gripper Fault : ", "Minor Fault: Changing mode fault, interference detected on Scissor (for less than 20 sec) (0x0A)")
	    elif (fault_status == 11):
		    textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
	    elif (fault_status == 13):
		    textmsg("Gripper Fault : ", "Major Fault: Activation fault, verify that no interference or other error occurred (0x0D)")
	    elif (fault_status == 14):
		    textmsg("Gripper Fault : ", "Major Fault: Changing mode fault, interference detected on Scissor (for more than 20 sec) (0x0E)")
	    elif (fault_status == 15):
		    textmsg("Gripper Fault : ", "Major Fault: Automatic release completed. Reset and activation is required (0x0F)")
	    else:
		    textmsg("Gripper Fault : ", "Unkwown Fault")
	    end
    end

    # sets the gripper inputs
    global rq_current_force = 0
    global rq_current_speed = 0
    def rq_set_var(name, value):
	
	    if (name == rq_rACT):
		    MOD = rq_get_var(rq_gMOD)
		    GTO = rq_get_var(rq_gGTO)
		    modbus_set_output_register("gripper_O0", 256 * (rq_rACT * value + rq_rMOD * MOD + rq_rGTO * GTO), False)
	    elif (name == rq_rMOD):
		    ACT = rq_get_var(rq_gACT)
		    GTO = rq_get_var(rq_gGTO)
		    modbus_set_output_register("gripper_O0", 256 * (rq_rACT * ACT + rq_rMOD * value + rq_rGTO * GTO), False)
	    elif (name == rq_rGTO):
		    ACT = rq_get_var(rq_gACT)
		    MOD = rq_get_var(rq_gMOD)
       	    modbus_set_output_register("gripper_O0", 256 * (rq_rACT * ACT + rq_rMOD * MOD + rq_rGTO * value), False)
	    elif (name == rq_rATR):
		    ACT = rq_get_var(rq_gACT)
		    MOD = rq_get_var(rq_gMOD)
		    GTO = rq_get_var(rq_gGTO)
       	    modbus_set_output_register("gripper_O0", 256 * (rq_rACT * ACT + rq_rMOD * MOD + rq_rGTO * GTO + rq_rATR * value), False)
	    elif (name == rq_rFOR):
		    rq_current_force = value
		    modbus_set_output_register("gripper_O2", (256 * rq_current_speed + value), False)
	    elif (name == rq_rSPE):
		    rq_current_speed = value
       	    modbus_set_output_register("gripper_O2", (256 * value + rq_current_force), False)
	    elif (name == rq_rPOS):
		    modbus_set_output_register("gripper_O1", value, False)
	    else:
	    end

	    sync()
    end

    # reads the gripper outputs
    def rq_get_var(name, nbr_bytes=0):
	    if (name == rq_gACT):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
		    value = binary_list_to_integer([reg[rq_gACT]])
	    elif (name == rq_gMOD):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
		    value = binary_list_to_integer([reg[rq_gMOD1], reg[rq_gMOD2]])
	    elif (name == rq_gGTO):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
		    value = binary_list_to_integer([reg[rq_gGTO]])
	    elif (name == rq_gSTA):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
		    value = binary_list_to_integer([reg[rq_gSTA1], reg[rq_gSTA2]])
	    elif (name == rq_gIMC):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
		    value = binary_list_to_integer([reg[rq_gIMC1], reg[rq_gIMC2]])
	    elif (name == rq_gFLT):
		    reg = integer_to_binary_list(modbus_get_signal_status("gripper_I1", False))
		    value = binary_list_to_integer([reg[rq_gFLT1], reg[rq_gFLT2], reg[rq_gFLT3], reg[rq_gFLT4]])
	    elif (name == rq_gPRE):
		    reg = modbus_get_signal_status("gripper_I1", False)
		    value = reg % 256
	    else:
   		    value = 0
	    end
     
	    sync()

	    return value
    end

    def rq_get_registers():
        #return [modbus_get_signal_status("gripper_I0", False),
        #        modbus_get_signal_status("gripper_I1", False),
        #        modbus_get_signal_status("gripper_I2", False),
        #        modbus_get_signal_status("gripper_I3", False),
        #        modbus_get_signal_status("gripper_I4", False),
        #        modbus_get_signal_status("gripper_I5", False),
        #        modbus_get_signal_status("gripper_I6", False),
        #        modbus_get_signal_status("gripper_I7", False)]
        return [0,0,0,0,0,0,0,0]
    end
end # gripper.script